class Solution:

    def search(self, nums: List[int], target: int) -> int:

        #have two pointers:

        l = 0
        r = len(nums) - 1
        
        while l <= r:
            #formula to update location

            #location = (l + r) // 2
            location = l + ((r - l) // 2) #overflow solution
            
            if nums[location] > target:
                #scope is now towards the left of the array
                r = location - 1

            elif nums[location] < target:
                #scope is now towards the right of the array
                l = location + 1
                
            else:
                return location
        
        return -1
        



        
'''

nums array sorted ascending order

you have an int target

implement a function to search for target

return index otherwise return -1

O(logn) time complexity

example:

Input: nums = [-1,0,2,4,6,8], target = 1

[-1,1,2,2,2,4,4,5,4] start in the middle

i = (len(nums) / 2

if n[i] < target:
    i = i / 2
    
if n[i] > target:
    i = len(nums) - i

if nums[i] == target:
    return i


Output: -1
'''


        